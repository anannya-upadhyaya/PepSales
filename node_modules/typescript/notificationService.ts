import { 
  Notification, 
  NotificationType, 
  NotificationStatus, 
  CreateNotificationDto, 
  INotificationDocument,
  INotification // Import the base interface if not already imported
} from 'typescript/notification';
import { queueService } from 'typescript/QueueService';
import { EmailProvider } from 'typescript/emailProvider';
import { SmsProvider } from 'typescript/smsProvider';
import { InAppProvider } from 'typescript/inAppProviders';
import { config } from 'typescript/config';
import mongoose from 'mongoose';

export class NotificationService {
  private emailProvider = new EmailProvider();
  private smsProvider = new SmsProvider();
  private inAppProvider = new InAppProvider();

  constructor() {
    this.setupNotificationProcessing();
  }

  async createNotification(data: CreateNotificationDto): Promise<any> {
    const notification = new Notification({
      userId: data.userId,
      type: NotificationType[data.type],
      title: data.title,
      content: data.content,
      metadata: data.metadata || {},
      status: NotificationStatus.PENDING,
      retryCount: 0
    });

    await notification.save();
    await queueService.enqueueNotification(notification.toObject());

    return this.mapToResponseDto(notification);
  }

  async getUserNotifications(userId: string): Promise<any[]> {
    const notifications = await Notification.find({ userId }).sort({ createdAt: -1 });
    return notifications.map(this.mapToResponseDto);
  }

  private async setupNotificationProcessing(): Promise<void> {
    await queueService.initialize();

    // Fix: Adjust the callback to match expected INotification type and safely handle id
    await queueService.consumeNotifications(async (notification: INotification) => {
      // The queue might be using either _id or id
      const notificationId = (notification as any)._id || (notification as any).id;
      if (!notificationId) {
        console.error('Notification missing ID:', notification);
        return;
      }
      
      const doc = await Notification.findById(notificationId);
      if (doc) await this.processNotification(doc);
    });

    // Fix: Adjust the callback to match expected INotification type and safely handle id
    await queueService.consumeFailedNotifications(async (notification: INotification) => {
      // The queue might be using either _id or id
      const notificationId = (notification as any)._id || (notification as any).id;
      if (!notificationId) {
        console.error('Failed notification missing ID:', notification);
        return;
      }
      
      const doc = await Notification.findById(notificationId);
      if (doc) await this.processFailedNotification(doc);
      else {
        // Create a temporary document-like object from the notification data
        const tempDoc = {
          ...notification,
          _id: notificationId
        } as unknown as INotificationDocument;
        await this.processFailedNotification(tempDoc);
      }
    });
  }

  private async processNotification(notification: INotificationDocument): Promise<void> {
    let success = false;

    switch (notification.type) {
      case NotificationType.EMAIL:
        success = await this.emailProvider.send(notification);
        break;
      case NotificationType.SMS:
        success = await this.smsProvider.send(notification);
        break;
      case NotificationType.IN_APP:
        success = await this.inAppProvider.send(notification);
        break;
      default:
        console.error(`[NotificationService] Unknown type: ${notification.type}`);
        break;
    }

    if (success) {
      await Notification.findByIdAndUpdate(notification._id, {
        status: NotificationStatus.SENT,
        sentAt: new Date()
      });
    } else {
      await this.handleFailedNotification(notification);
    }
  }

  private async processFailedNotification(notification: INotificationDocument): Promise<void> {
    const retryCount = (notification.retryCount || 0) + 1;

    if (retryCount > config.notification.maxRetries) {
      await Notification.findByIdAndUpdate(notification._id, {
        status: NotificationStatus.FAILED,
        retryCount
      });
      return;
    }

    await Notification.findByIdAndUpdate(notification._id, {
      status: NotificationStatus.RETRYING,
      retryCount
    });

    await new Promise(resolve => setTimeout(resolve, config.notification.retryInterval));

    const updated = await Notification.findById(notification._id);
    if (updated) {
      await this.processNotification(updated);
    }
  }

  private async handleFailedNotification(notification: INotificationDocument): Promise<void> {
    await Notification.findByIdAndUpdate(notification._id, {
      status: NotificationStatus.RETRYING
    });

    await queueService.enqueueFailedNotification(notification);
  }

  private mapToResponseDto(notification: INotificationDocument): any {
    return {
      id: notification._id.toString(),
      userId: notification.userId,
      type: notification.type,
      title: notification.title,
      content: notification.content,
      status: notification.status ?? NotificationStatus.PENDING,
      createdAt: notification.createdAt,
      sentAt: notification.sentAt
    };
  }
}

export const notificationService = new NotificationService();