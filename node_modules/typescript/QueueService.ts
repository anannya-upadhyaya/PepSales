import * as amqp from 'amqplib';
import { Connection, Channel } from 'amqplib';
import { config } from 'typescript/config';
import { INotification } from 'typescript/notification';

export class QueueService {
  private connection: Connection | null = null;
  private channel: Channel | null = null;

  async initialize(): Promise<void> {
    try {
      // Use type assertion to work around TypeScript definition issues
      this.connection = await amqp.connect(config.rabbitmq.url) as any;
      this.channel = await (this.connection as any).createChannel();

      // Ensure channel is not null after creation
      const channel = this.ensureChannel();
      
      // Fix: Add type assertion to ensure TypeScript recognizes exchangeName as a string
      await channel.assertExchange(
        config.rabbitmq.exchangeName as unknown as string, 
        'direct', 
        { durable: true }
      );

      await channel.assertQueue(config.rabbitmq.queues.notifications, { durable: true });
      await channel.assertQueue(config.rabbitmq.queues.failedNotifications, { durable: true });

      await channel.bindQueue(
        config.rabbitmq.queues.notifications,
        config.rabbitmq.exchangeName as unknown as string,
        'notification'
      );
      await channel.bindQueue(
        config.rabbitmq.queues.failedNotifications,
        config.rabbitmq.exchangeName as unknown as string,
        'failed'
      );

      console.log('[QueueService] Successfully connected to RabbitMQ');
    } catch (error) {
      console.error('[QueueService] Failed to initialize RabbitMQ:', error);
      throw error;
    }
  }

  private ensureChannel(): Channel {
    if (!this.channel) {
      throw new Error('[QueueService] Channel is not initialized.');
    }
    return this.channel;
  }

  async enqueueNotification(notification: INotification): Promise<boolean> {
    try {
      if (!this.channel) {
        await this.initialize();
      }

      // Use the ensureChannel method which already has null checking
      const channel = this.ensureChannel();
      const published = channel.publish(
        config.rabbitmq.exchangeName as unknown as string,
        'notification',
        Buffer.from(JSON.stringify(notification)),
        { persistent: true }
      );

      if (!published) {
        console.warn('[QueueService] Notification was not flushed to the buffer immediately');
      }

      return published;
    } catch (error) {
      console.error('[QueueService] Failed to enqueue notification:', error);
      return false;
    }
  }

  async enqueueFailedNotification(notification: INotification): Promise<boolean> {
    try {
      if (!this.channel) {
        await this.initialize();
      }

      // Use the ensureChannel method which already has null checking
      const channel = this.ensureChannel();
      const published = channel.publish(
        config.rabbitmq.exchangeName as unknown as string,
        'failed',
        Buffer.from(JSON.stringify(notification)),
        { persistent: true }
      );

      if (!published) {
        console.warn('[QueueService] Failed notification was not flushed to the buffer immediately');
      }

      return published;
    } catch (error) {
      console.error('[QueueService] Failed to enqueue failed notification:', error);
      return false;
    }
  }

  async consumeNotifications(callback: (notification: INotification) => Promise<void>): Promise<void> {
    try {
      if (!this.channel) {
        await this.initialize();
      }

      // Use the ensureChannel method which already has null checking
      const channel = this.ensureChannel();
      await channel.consume(
        config.rabbitmq.queues.notifications,
        async (msg) => {
          if (msg) {
            try {
              const notification: INotification = JSON.parse(msg.content.toString());
              await callback(notification);
              // Store channel in a local variable to avoid possible null issues
              const channel = this.ensureChannel();
              channel.ack(msg);
            } catch (error) {
              console.error('[QueueService] Error processing notification:', error);
              const channel = this.ensureChannel();
              channel.nack(msg, false, true);
            }
          }
        },
        { noAck: false }
      );

      console.log('[QueueService] Started consuming notifications');
    } catch (error) {
      console.error('[QueueService] Failed to consume notifications:', error);
      throw error;
    }
  }

  async consumeFailedNotifications(callback: (notification: INotification) => Promise<void>): Promise<void> {
    try {
      if (!this.channel) {
        await this.initialize();
      }

      // Use the ensureChannel method which already has null checking
      const channel = this.ensureChannel();
      await channel.consume(
        config.rabbitmq.queues.failedNotifications,
        async (msg) => {
          if (msg) {
            try {
              const notification: INotification = JSON.parse(msg.content.toString());
              await callback(notification);
              // Store channel in a local variable to avoid possible null issues
              const channel = this.ensureChannel();
              channel.ack(msg);
            } catch (error) {
              console.error('[QueueService] Error processing failed notification:', error);
              const channel = this.ensureChannel();
              channel.nack(msg, false, true);
            }
          }
        },
        { noAck: false }
      );

      console.log('[QueueService] Started consuming failed notifications');
    } catch (error) {
      console.error('[QueueService] Failed to consume failed notifications:', error);
      throw error;
    }
  }

  async close(): Promise<void> {
    try {
      if (this.channel) {
        await this.channel.close();
      }
      if (this.connection) {
        // Use type assertion to tell TypeScript that close() exists
        await (this.connection as any).close();
      }
      console.log('[QueueService] Closed RabbitMQ connection');
    } catch (error) {
      console.error('[QueueService] Error closing RabbitMQ connection:', error);
    }
  }
}

// Export a singleton instance
export const queueService = new QueueService();